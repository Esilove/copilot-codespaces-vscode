// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/171819202111121314151612345678910
// Â© robbatt

import TradingView/ta/8
import robbatt/lib_plot_objects/49 as D
import robbatt/lib_profile/34 as PF
import robbatt/lib_no_delay/4 as ND
import robbatt/lib_math/2 as M

//v1073 - started live tracking for OrderBlocks
//v1479 - last debug
//v1487 - finalized live tracking OrderBlocks
//v1499 - v21 + fix current swing level display
//v1503 - temp debug
//v1508 - v2 + removed logging
//v1510 - v3 + minor refactoring
//@version=6
library("lib_smc", overlay = true)

////////////////////////////////////////////////////////////

// derived from Smart Money Concepts by LuxAlgo - https://www.tradingview.com/script/CnB3fSph-Smart-Money-Concepts-LUX/

//-----------------------------------------------------------------------------}
//Functions
//-----------------------------------------------------------------------------{

//Swings detection/measurements
// @function INTERNAL: detect swing points (HH and LL) in given range
// @param len range to check for new swing points
// @param h reference high to detect swing highs with
// @param l reference low to detect swing lows with
// @returns [idx, hh, ll] values are the price level where and if a new HH or LL was detected, else na
export swings(simple int len)=>
    var os = 0
    float hh = na
    float ll = na
    int idx = na
    
    h_swing = high[len]
    l_swing = low[len]
    upper = ta.highest(high, len)
    lower = ta.lowest(low, len)
    
    os := h_swing > upper ? 0 : l_swing < lower ? 1 : os[1]
    hh := os == 0 and os[1] != 0 ? h_swing : na
    ll := os == 1 and os[1] != 1 ? l_swing : na
    idx := not na(hh) or not na(ll) ? bar_index-len : na

    [idx, hh, ll]

export type OrderBlock
    int id
    int dir
    chart.point left_top
    chart.point right_bottom
    float break_price
    float early_confirmation_price    

    float[] ltf_high
    float[] ltf_low
    float[] ltf_volume

    D.Box plot
    PF.Profile profile

    float probability = 0
    bool trailing = false
    bool extending = false
    bool awaiting_confirmation = false
    bool touched_break_price_before_confirmation = false
    bool soft_confirmed = false // price closed outside block after stop ext
    bool has_fvg_out = false
    bool hidden = false
    bool broken = false

export type OrderBlockConfig
    bool show = true
    int show_last = 5
    bool show_id = false
    bool show_profile = false
    bool show_probability = false
    D.BoxArgs args
    string txt = 'OB'
    D.BoxTextArgs txt_args
    
    bool delete_when_broken = true

    D.BoxArgs broken_args = na
    string broken_txt = ''
    D.BoxTextArgs broken_txt_args = na
    PF.ProfileArgs broken_profile_args = na
    
    bool use_profile = false
    PF.ProfileArgs profile_args = na

export method init (OrderBlockConfig this) =>
    if not na(this)
        if na(this.args)
            this.args := D.BoxArgs.new(#00000000, bg_color = color.new(chart.fg_color, 95), xloc = xloc.bar_time)
        if na(this.txt_args)
            this.txt_args := D.BoxTextArgs.new(chart.fg_color, size.tiny, text_halign = text.align_right)
        if na(this.broken_args)
            this.broken_args := D.BoxArgs.new(#00000000, bg_color = color.new(chart.fg_color, 99), xloc = xloc.bar_time)
        if na(this.broken_txt_args)
            this.broken_txt_args := D.BoxTextArgs.new(#00000000)
        if na(this.profile_args)
            this.profile_args := PF.ProfileArgs.new().init()

export method delete(OrderBlock this) =>
    if not na(this)
        this.plot.delete()
        this.profile.delete()


// @function INTERNAL: delete internal order blocks box coordinates if top/bottom is broken
// @param ob_top ob coordinates top
// @param ob_btm ob coordinates btm
// @param ob_left ob coordinates left
// @param ob_type ob coordinates type
// @returns any_bull_ob_broken, any_bear_ob_broken, broken signals are true if an according order block was broken/mitigated, broken contains the broken block(s)
export method clear_broken(map<int,OrderBlock> this, map<int,OrderBlock> broken_buffer) =>
    broken = array.new<OrderBlock>()

    if barstate.isconfirmed
        for ob in this.values()
            ob.broken := switch ob.dir
                1  => close < ob.break_price
                -1 => close > ob.break_price
                => false

            if ob.broken
                ob.right_bottom.time  := time
                ob.right_bottom.index := bar_index
                broken.push(this.remove(ob.left_top.index))
                if not na(broken_buffer)
                    broken_buffer.put(ob.left_top.index, ob)
                ob.delete()

    broken

//Order block coordinates function
// @function INTERNAL: set internal order block coordinates
// @param mode 1: bullish, -1 bearish block
// @param len lookback period to detect order blocks
// @param enabled enable calculation, if false this function just does nothing
// @param blocks blocks buffer
// @param ob_threshold ob size limit (candle size high-low must be smaller than this threshold)
// @returns [any_bull_ob_broken, any_bear_ob_broken] signals are true if an according order block was broken/mitigated
export create_ob(int id, int mode, int start_t, int start_i, float top, int end_t, int end_i, float bottom, float break_price = na, float early_confirmation_price = na, OrderBlockConfig config = na, bool init_plot = false, bool force_overlay = false) =>
    var tf_ms = timeframe.in_seconds() * 1000

    OrderBlock block = OrderBlock.new(id, mode,
     chart.point.new(start_t, start_i, top),
     chart.point.new(end_t, end_i, bottom),
     not na(break_price) ? break_price : mode == 1 ? top : bottom,
     early_confirmation_price,
     array.new<float>(0),
     array.new<float>(0),
     array.new<float>(0)
     )
     
    if init_plot
        block.plot := D.create_box(block.left_top, block.right_bottom, config.txt, config.args, config.txt_args, init_plot, force_overlay)

    block


export method align_to_profile(OrderBlock block, bool align_edge = false, bool align_break_price = false) =>
    // align block to profile
    if not na(block.profile)
        if align_edge and not na(block.profile.vah)
            block.left_top.price     := block.profile.vah
            block.right_bottom.price := block.profile.val
        if align_break_price and not na(block.profile.poc)
            block.break_price        := block.profile.poc
    block

//@description takes series of high/low/value as parameter and extracts profiling data from given candles to the block. CALL THIS BEFORE FIRST draw(), otherwise draw will manipulate the end point and create_profile will consider all candles within extended block
//@param profile the series of Profiles generated for each bar
method _create_profile(OrderBlock block, float[] opens = na, float[] tops, float[] bottoms, float[] closes = na, float[] values, int resolution = 20, float vah_pc = 80, float val_pc = 20, PF.ProfileArgs args = na, bool init_calculated = true, bool init_plot = false, bool force_overlay = false) =>
    if na(block.profile) // init
        block.profile := PF.create_profile(block.left_top.time, block.left_top.index, block.right_bottom.time, block.right_bottom.index, opens, tops, bottoms, closes, values, args, resolution, vah_pc, val_pc, init_calculated, init_plot, force_overlay)
    else // update profile
        block.profile.start_t := block.left_top.time
        block.profile.start_i := block.left_top.index
        block.profile.end_t := block.right_bottom.time
        block.profile.end_i := block.right_bottom.index
        block.profile.update(opens, tops, bottoms, closes, values, block.right_bottom.time, block.right_bottom.index)

    block

//@description takes series of high/low/value as parameter and extracts profiling data from given candles to the block. CALL THIS BEFORE FIRST draw(), otherwise draw will manipulate the end point and create_profile will consider all candles within extended block
//@param profile the series of Profiles generated for each bar
export method create_profile(OrderBlock block, float[] opens, float[] tops, float[] bottoms, float[] closes, float[] values, int resolution = 20, float vah_pc = 80, float val_pc = 20, PF.ProfileArgs args = na, bool capture_directional_volume = false, bool init_calculated = true, bool init_plot = false, bool force_overlay = false) =>

    if barstate.isconfirmed and not na(block)
        start = bar_index - block.left_top.index
        end = bar_index - block.right_bottom.index
        size = block.right_bottom.index - block.left_top.index + 1
        use_open_close = size <= args.max_range_to_use_open_close_data or capture_directional_volume

        data_tops = array.copy(tops[start])
        data_bottoms = array.copy(bottoms[start])
        data_values = array.copy(values[start])
        data_opens = use_open_close ? array.copy(opens[start]) : na
        data_closes = use_open_close ? array.copy(closes[start]) : na
        
        if start > end // block longer than one candle
            for i = start to end
                data_tops.concat(tops[i])
                data_bottoms.concat(bottoms[i])
                data_values.concat(values[i])

                if use_open_close
                    data_opens.concat(opens[i])
                    data_closes.concat(closes[i])
                    
            
        block._create_profile(data_opens, data_tops, data_bottoms, data_closes, data_values, resolution, vah_pc, val_pc, args, init_calculated, init_plot, force_overlay)        

    block


//@description take a series of Profiles as parameter and apply the one matching the OrderBlock to it
//@param profile the series of Profiles generated for each bar
export method create_profile(OrderBlock block, int resolution = 20, float vah_pc = 80, float val_pc = 20, PF.ProfileArgs args = na, bool capture_directional_volume = false, bool init_calculated = true, bool init_plot = false, bool force_overlay = false) =>

    if not na(block) and barstate.isconfirmed

        start = bar_index - block.left_top.index
        end = bar_index - block.right_bottom.index
        size = block.right_bottom.index - block.left_top.index + 1
        use_open_close = size <= args.max_range_to_use_open_close_data or capture_directional_volume

        data_tops = array.from(high[start])
        data_bottoms = array.from(low[start])
        data_values = array.from(volume[start])

        data_opens = use_open_close ? array.from(open[start]) : na
        data_closes = use_open_close ? array.from(close[start]) : na
        
        if start > end // block longer than one candle
            for i = start-1 to end
                data_tops.push(high[i])
                data_bottoms.push(low[i])
                data_values.push(volume[i])

                if use_open_close
                    data_opens.push(open[i])
                    data_closes.push(close[i])

        block._create_profile(data_opens, data_tops, data_bottoms, data_closes, data_values, resolution, vah_pc, val_pc, args, init_calculated, init_plot, force_overlay)

    block


method overlaps_range(OrderBlock this, float range_top = 0, float range_btm = 0) =>
    na(this) ? false : M.range_overlap(this.left_top.price, this.right_bottom.price, range_top, range_btm)

//@function check if last block in list overlaps a potential new OB range
method last_overlaps(OrderBlock[] this, float range_top, float range_btm) =>
    na(this) ? false : this.size() > 0 ? this.last().overlaps_range(range_top, range_btm) : false

update_broken(int mode, OrderBlock[] tracking_blocks, OrderBlock[] broken_blocks, bool needs_cross_after_confirm = false, bool clear_broken_buffer_before = false) =>
    var tf_ms = timeframe.in_seconds() * 1000
    var max_check_hidden = 2
    checked_hidden = 0
    // clear out broken blocks
    if clear_broken_buffer_before
        broken_blocks.clear()

    tracking_size = tracking_blocks.size()
    if tracking_size > 0
        for i = tracking_size - 1 to 0
            block = tracking_blocks.get(i)

            if checked_hidden >= max_check_hidden
                break
            else if block.hidden
                checked_hidden += 1

            if not needs_cross_after_confirm or barstate.isconfirmed

                src = needs_cross_after_confirm ? close : mode == 1 ? low : high

                if mode == 1 ? block.break_price > src : block.break_price < src
                    block.broken := true
                    broken_blocks.unshift(block)
                    tracking_blocks.remove(i)
                    if broken_blocks.size() > 100
                        broken_blocks.pop()

    true // return something to avoid error for different returns from if/else paths

method reset_tracking(OrderBlock this) =>
    var tf_ms = timeframe.in_seconds() / 1000
  
    this.ltf_high   :=  array.new<float>(0)
    this.ltf_low    :=  array.new<float>(0)
    this.ltf_volume :=  array.new<float>(0)

    this.trailing := true
    this.extending := false
    this.awaiting_confirmation := false
    this.touched_break_price_before_confirmation := false
    this.soft_confirmed := false
    this.has_fvg_out := false
    this.broken := false

    this.left_top := chart.point.now(high)
    this.right_bottom := chart.point.now(low)
    this.early_confirmation_price := na
    this.break_price := hl2
  

export track_obs(int swing_len, float hh, float ll, float top, float btm, bool bull_bos_alert, bool bull_choch_alert, bool bear_bos_alert, bool bear_choch_alert, float min_block_size, float max_block_size, OrderBlockConfig config_bull, OrderBlockConfig config_bear, bool init_plot = false, bool force_overlay = false, bool enabled = true, simple bool extend_blocks = true, simple bool clear_broken_buffer_before = false, simple bool align_edge_to_value_area = false, simple bool align_break_price_to_poc = false, simple bool capture_directional_volume = false, PF.ProfileArgs profile_args_bull = na, PF.ProfileArgs profile_args_bear = na, simple bool use_soft_confirm = true, float soft_confirm_offset = 0, simple bool use_retracements_with_FVG_out = true) =>
    var OrderBlock[] tracking_blocks_bull = array.new<OrderBlock>(0)
    var OrderBlock[] tracking_blocks_bear = array.new<OrderBlock>(0)
    var OrderBlock[] broken_blocks_bull = array.new<OrderBlock>(0)
    var OrderBlock[] broken_blocks_bear = array.new<OrderBlock>(0)

    var tf_ms = timeframe.in_seconds() / 1000

    // sanity check
    if barstate.isfirst
        if  (na(config_bull.broken_profile_args) ? false : config_bull.broken_profile_args.xloc  == xloc.bar_index)        
         or (na(config_bear.broken_profile_args) ? false : config_bear.broken_profile_args.xloc  == xloc.bar_index)
         or (na(config_bull.profile_args)        ? false : config_bull.profile_args.xloc         == xloc.bar_index)
         or (na(config_bear.profile_args)        ? false : config_bear.profile_args.xloc         == xloc.bar_index)
         or (na(config_bull.args)                ? false : config_bull.args.xloc                 == xloc.bar_index)
         or (na(config_bear.args)                ? false : config_bear.args.xloc                 == xloc.bar_index)
         or (na(config_bull.broken_args)         ? false : config_bull.broken_args.xloc          == xloc.bar_index)
         or (na(config_bear.broken_args)         ? false : config_bear.broken_args.xloc          == xloc.bar_index)
            runtime.error('use xloc = xloc.bar_time for OrderBlockConfig.[args/broken_args/profile_args/broken_profile_args], to avoid crashes when older OrderBlocks reappear after newer ones have been broken. This requires a redraw but in case the block starts >= 285 bars before bar_index, the internal buffers will not be able to deliver values and crash the script.')
        
    var int next_id = 0
    var OrderBlock bull_ob = create_ob(0,  1, time, bar_index, high, time, bar_index, low, hl2, config = config_bull)
    var OrderBlock bear_ob = create_ob(0, -1, time, bar_index, high, time, bar_index, low, hl2, config = config_bear)
    if barstate.isfirst
        bull_ob.reset_tracking()
        bear_ob.reset_tracking()

    var float ob_size_min_bull = min_block_size, var float ob_size_min_bear = min_block_size
    var float ob_size_max_bull = max_block_size, var float ob_size_max_bear = max_block_size

    bool is_green = open < close
    bool is_red = close < open
    bool no_move = ta.tr == 0
    float candle_top = math.max(open, close)
    float candle_btm = math.min(open, close)
    float candle_body = math.abs(open - close)
    bool is_indecision = M.in_range(high, low, high[1], low[1]) and candle_body[1] > candle_body
     or M.in_range(candle_top, candle_btm, candle_top[1], candle_btm[1])
     or open == close
    bool is_unlocked_equilibrium_confirmation_bull = false
    bool is_unlocked_equilibrium_confirmation_bear = false
    OrderBlock bull_ob_confirmed = na
    OrderBlock bear_ob_confirmed = na

    if ta.change(top) != 0
        is_unlocked_equilibrium_confirmation_bear := true
    if ta.change(btm) != 0
        is_unlocked_equilibrium_confirmation_bull := true

    if enabled
        update_broken( 1, tracking_blocks_bull, broken_blocks_bull, clear_broken_buffer_before)
        update_broken(-1, tracking_blocks_bear, broken_blocks_bear, clear_broken_buffer_before)  

        // phase 1 hhll trailing (if last block is exceeded before confirmation) (in mode direction) 
        if bull_ob.trailing 
            _check_start_t = bull_ob.left_top.time
            _check_start_i = bull_ob.left_top.index
            _check_end_t = bull_ob.right_bottom.time
            _check_end_i = bull_ob.right_bottom.index
            _check_top = bull_ob.left_top.price
            _check_btm = bull_ob.right_bottom.price
            _check_break  = math.avg(_check_top, _check_btm)
            _check_ext = bull_ob.extending

            if bull_ob.right_bottom.price > low // (mode == 1 ? low_point.price > low : high_point.price < high) // tracking // phase 1

                // CHECK FLIP BULL->BEAR by FVG DOWN - if the current bullish retracement tracks further down with an FVG crossing the previous block bottom edge, consider it a soft confirmation and add it directly as new block
                if barstate.isconfirmed and _check_start_i < bar_index - 1 and use_retracements_with_FVG_out and low[2] > _check_btm[1] and _check_btm[1] > low // for an FVG to span across _check_btm, at least 2 candles need to be lower than bull_ob's btm, therefore _check_btm will be set by the middle FVG candle, and the last can access _check_btm[1] safely
                    if not _check_ext[2] // means we already hit a stop ext once and did not extend since then, so this FVG leaves the block directly
                     and not tracking_blocks_bear.last_overlaps(_check_top[2], _check_btm[2]) // not overlapping previous block
                     and not bear_ob.overlaps_range(_check_top[2], _check_btm[2])

                        next_id += 1
                        bear_ob_confirmed := create_ob(next_id, 1, _check_start_t[2], _check_start_i[2], _check_top[2], _check_end_t[2], _check_end_i[2], _check_btm[2], _check_break[2], _check_top[2], config_bear, init_plot, force_overlay )
                        bear_ob_confirmed.has_fvg_out := true

                        if barstate.isconfirmed and (align_edge_to_value_area or align_break_price_to_poc)
                            if na(bull_ob.profile)
                                bear_ob_confirmed.create_profile(args = profile_args_bear, capture_directional_volume = capture_directional_volume)
                            else
                                bear_ob_confirmed.profile := bull_ob.profile
                                bear_ob_confirmed.profile.args := profile_args_bear

                            bear_ob_confirmed.align_to_profile(align_edge_to_value_area, align_break_price_to_poc)

                        bear_ob_confirmed.right_bottom.index := bar_index
                        bear_ob_confirmed.right_bottom.time := time
                        tracking_blocks_bear.push(bear_ob_confirmed)

                // TRACKING BULL DOWN
                bull_ob.reset_tracking()
                bull_ob.early_confirmation_price := math.avg(top,low)

                if barstate.isconfirmed
                    bull_ob.profile := na

            // INIT EXTENSION ON 2nd BAR
            else if bull_ob.left_top.index == bar_index-1 and extend_blocks
                bull_ob.extending := true

            // phase 1+2 block extension (candle color opposite mode, also when new hhll and candle is trailing block up)
            // BULL EXTENSION UP, reset poc touch, reset soft confirm
            if bull_ob.extending and is_green and bull_ob.left_top.price < high // (mode == 1 ? is_green and high_point.price < high : is_red and low_point.price > low)
                bull_ob.left_top.price := high
                bull_ob.right_bottom := chart.point.now(bull_ob.right_bottom.price)
                bull_ob.touched_break_price_before_confirmation := false
                bull_ob.soft_confirmed := false

        if bear_ob.trailing
            _check_start_t = bear_ob.left_top.time
            _check_start_i = bear_ob.left_top.index
            _check_end_t = bear_ob.right_bottom.time
            _check_end_i = bear_ob.right_bottom.index
            _check_top = bear_ob.left_top.price
            _check_btm = bear_ob.right_bottom.price
            _check_break  = math.avg(_check_top, _check_btm)
            _check_ext = bear_ob.extending

            if bear_ob.left_top.price < high

                // CHECK FLIP BEAR->BULL by FVG UP - if the current bearish retracement tracks further up with an FVG crossing the previous block top edge, consider it a soft confirmation and add it directly as new block
                if barstate.isconfirmed and use_retracements_with_FVG_out and high[2] < _check_top[1] and _check_top[1] < low // for an FVG to span across _check_top, at least 2 candles need to be higher than bear_ob's top, therefore _check_top will be set by the middle FVG candle, and the last can access _check_top[1] safely

                    if not _check_ext[2] // stopped extension already, and not extending since then, so this FVG leaves the block directly
                     and not tracking_blocks_bull.last_overlaps(_check_top[2], _check_btm[2]) // FVG flipped block does not overlap previous block
                     and not bull_ob.overlaps_range(_check_top[2], _check_btm[2])
                     
                        next_id += 1
                        bull_ob_confirmed := create_ob(next_id, 1, _check_start_t[2], _check_start_i[2], _check_top[2], _check_end_t[2], _check_end_i[2], _check_btm[2], _check_break[2], _check_top[2], config_bull, init_plot, force_overlay )
                        bull_ob_confirmed.has_fvg_out := true    

                        if barstate.isconfirmed and (align_edge_to_value_area or align_break_price_to_poc)
                            if na(bear_ob.profile)
                                bull_ob_confirmed.create_profile(args = profile_args_bull, capture_directional_volume = capture_directional_volume)
                            else
                                bull_ob_confirmed.profile := bear_ob.profile
                                bull_ob_confirmed.profile.args := profile_args_bull

                            bull_ob_confirmed.align_to_profile(align_edge_to_value_area, align_break_price_to_poc)

                        bull_ob_confirmed.right_bottom.index := bar_index
                        bull_ob_confirmed.right_bottom.time := time
                        tracking_blocks_bull.push(bull_ob_confirmed)
                
                // TRACKING BEAR UP
                bear_ob.reset_tracking()
                bear_ob.early_confirmation_price := math.avg(high,btm)

                if barstate.isconfirmed
                    bear_ob.profile := na

            // INIT EXTENSION ON 2nd BAR
            else if bear_ob.left_top.index == bar_index-1 and extend_blocks        
                bear_ob.extending := true

            // BEAR EXTENSION DOWN, reset poc touch, reset soft confirm
            if bear_ob.extending and is_red // test without this ... including every bar that stays inside the block ... // and bear_ob.right_bottom.price > low
                bear_ob.right_bottom := chart.point.now(math.min(bear_ob.right_bottom.price,low))
                bear_ob.touched_break_price_before_confirmation := false
                bear_ob.soft_confirmed := false
                
        // phase 2   end block extension (when next candle closes in mode direction) -> Signal to reset opposite block and restart tracking
        if barstate.isconfirmed

            // STOP BULL EXTENSION
            if bull_ob.trailing and bull_ob.extending and bull_ob.left_top.index < bar_index and is_red and not is_indecision and M.in_range(close, bull_ob.left_top.price, bull_ob.right_bottom.price)
                bull_ob.left_top.price := math.max(open, bull_ob.left_top.price)
                bull_ob.right_bottom := chart.point.new(time[1], bar_index[1], bull_ob.right_bottom.price)
            
                bull_ob.extending := false
                bull_ob.awaiting_confirmation := true

                ob_length        = bull_ob.right_bottom.index - bull_ob.left_top.index + 1
                ob_size_min_bull := math.round_to_mintick(min_block_size)
                ob_size_max_bull := math.round_to_mintick(max_block_size * ob_length)
                
                if align_edge_to_value_area or align_break_price_to_poc
                    bull_ob.create_profile(args = profile_args_bull, capture_directional_volume = capture_directional_volume) // uses coordinates from block and default high/low/volume series as data
                     // don't align edges yet, we want FVG out to check the original edge, align on confirmation
                    bull_ob.align_to_profile(align_break_price = true) // aligning poc, but not edge, so FVG out check will still check for having crossed the original edge. Will align edges on FVG/soft/regular confirmation
                    

                // bear reset
                if not bear_ob.awaiting_confirmation and not bear_ob.extending // not bear_ob.trailing and 
                    bear_ob.reset_tracking()


            // STOP BEAR EXTENSION            
            if bear_ob.trailing and bear_ob.extending and bear_ob.left_top.index < bar_index and is_green and not is_indecision and  M.in_range(close, bear_ob.left_top.price, bear_ob.right_bottom.price)
                bear_ob.left_top.price := math.max(open, bear_ob.left_top.price)
                bear_ob.right_bottom := chart.point.new(time[1], bar_index[1], bear_ob.right_bottom.price)
            
                bear_ob.extending := false                
                bear_ob.awaiting_confirmation := true

                ob_length        = bear_ob.right_bottom.index - bear_ob.left_top.index + 1
                ob_size_min_bear := min_block_size
                ob_size_max_bear := max_block_size * ob_length

                if align_edge_to_value_area or align_break_price_to_poc
                    bear_ob.create_profile(args = profile_args_bear, capture_directional_volume = capture_directional_volume) // uses coordinates from block and default high/low/volume series as data                    
                    // don't align edges yet, we want FVG out to check the original edge, align on confirmation
                    bear_ob.align_to_profile(align_break_price = true) // aligning poc, but not edge, so FVG out check will still check for having crossed the original edge. Will align edges on FVG/soft/regular confirmation

                // reset bull
                if not bull_ob.awaiting_confirmation and not bull_ob.extending // not bull_ob.trailing and 
                    bull_ob.reset_tracking()

        // phase 3   block confirmation when age block start > len OR opposite BOS/CHoCH (aka opposite confirmed block was broken)
        if bull_ob.trailing and bull_ob.awaiting_confirmation

            // SOFT CONFIRMATION BULL
            if barstate.isconfirmed and not bull_ob.soft_confirmed
                if not bull_ob.touched_break_price_before_confirmation
                    if bull_ob.break_price > low and bull_ob.right_bottom.index < bar_index // touched break price before confirmation
                        bull_ob.touched_break_price_before_confirmation := true

                if bull_ob.touched_break_price_before_confirmation and bull_ob.left_top.price + soft_confirm_offset < close // price touched POC and closes outside block -> soft confirmation
                    bull_ob.soft_confirmed := true

                    
            // else 
            // NORMAL CONFIRMATION BULL
            if bull_ob.left_top.price + soft_confirm_offset < close and barstate.isconfirmed
             and ( // any condition for bullish OB confirmation
             bull_ob.soft_confirmed and use_soft_confirm
             or not na(ll) // LL swing point confirmed
             or bull_bos_alert // previous High broken
             or bull_choch_alert // previous HH broken + trend direction changed
             or bar_index - bull_ob.right_bottom.index >= swing_len // OB has not been extended longer than tracked swing period (could have been created but there is no new swing point due to long trending market)
             )
         
                if align_edge_to_value_area
                 ? M.in_range(math.round_to_mintick(bull_ob.profile.vah - bull_ob.profile.val), ob_size_max_bull, ob_size_min_bull)
                 : M.in_range(math.round_to_mintick(bull_ob.left_top.price - bull_ob.right_bottom.price), ob_size_max_bull, ob_size_min_bull) // ( bar_index - (mode == 1 ? low_point : high_point).index > swing_len or opposite_bos_or_choch)
                    bull_ob.trailing := false
                    bull_ob_confirmed := bull_ob.copy() // copy only the reference to the profile, not the profile and it's plot objects, their coordinates might out of the buffer already
                    bull_ob_confirmed.left_top := bull_ob.left_top.copy()
                    bull_ob_confirmed.right_bottom := bull_ob.right_bottom.copy() // must not extend, so create_profile get's only the actual block, resolve display issues in draw() // chart.point.now(bull_ob.right_bottom.price)
                                        
                    // bull_ob_confirmed.profile := bull_ob.profile.deep_copy() => creating error when coordinates are older than buffer (284 bars), setting profile of developing ob to na instead, to be recreated on stop ext
                    if align_edge_to_value_area or align_break_price_to_poc
                        bull_ob_confirmed.profile := bull_ob.profile
                        bull_ob_confirmed.align_to_profile(align_edge_to_value_area, align_break_price_to_poc)

                    if not align_break_price_to_poc
                        bull_ob_confirmed.break_price := math.avg(bull_ob.left_top.price, bull_ob.right_bottom.price)
                    bull_ob.profile := na
                    
                    bull_ob_confirmed.plot := D.create_box(bull_ob_confirmed.left_top, bull_ob_confirmed.right_bottom, config_bull.txt, config_bull.args, config_bull.txt_args, init_plot, force_overlay )
                    tracking_blocks_bull.push(bull_ob_confirmed)

                    // START NEXT BULL BLOCK
                    if barstate.isconfirmed // and bull_ob.early_confirmation_price < close
                        bull_ob.reset_tracking()

                    next_id += 1
                    bull_ob.id := next_id
                    is_unlocked_equilibrium_confirmation_bull := false

                else // INVALID SIZE, START NEXT BULL BLOCK
                    bull_ob.reset_tracking()
                
        
        if bear_ob.trailing and bear_ob.awaiting_confirmation

            // SOFT CONFIRMATION BEAR
            if barstate.isconfirmed and not bear_ob.soft_confirmed
                if not bear_ob.touched_break_price_before_confirmation
                    if bear_ob.break_price < high and bear_ob.right_bottom.index < bar_index // broken before confirmation
                        bear_ob.touched_break_price_before_confirmation := true
                    
                if bear_ob.touched_break_price_before_confirmation and bear_ob.right_bottom.price - soft_confirm_offset > close // price touched POC and closes outside block -> soft confirmation
                    bear_ob.soft_confirmed := true

            // else 
            // NORMAL CONFIRMATION BEAR
            if bear_ob.right_bottom.price - soft_confirm_offset > close and barstate.isconfirmed
             and ( // any condition for bearish OB confirmation
             bear_ob.soft_confirmed and use_soft_confirm
             or not na(hh) // HH swing point confirmed
             or bear_bos_alert // previous Low broken
             or bear_choch_alert // previous LL broken -> trend direction changed
             or bar_index - bear_ob.right_bottom.index >= swing_len // OB has not been extended longer than tracked swing period (could have been created but there is no new swing point due to long trending market)
             )
                if align_edge_to_value_area
                 ? M.in_range(math.round_to_mintick(bear_ob.profile.vah - bear_ob.profile.val), ob_size_max_bear, ob_size_min_bear)
                 : M.in_range(math.round_to_mintick(bear_ob.left_top.price - bear_ob.right_bottom.price), ob_size_max_bear, ob_size_min_bear)
                    bear_ob.trailing := false
                    bear_ob_confirmed := bear_ob.copy() // copy only the reference to the profile, not the profile and it's plot objects, their coordinates might out of the buffer already
                    bear_ob_confirmed.left_top := bear_ob.left_top.copy()
                    bear_ob_confirmed.right_bottom := bear_ob.right_bottom.copy() // must not extend, so create_profile get's only the actual block, resolve display issues in draw() // chart.point.now(bear_ob.right_bottom.price)
                    
                    if align_edge_to_value_area or align_break_price_to_poc
                        bear_ob_confirmed.profile := bear_ob.profile // reusing this profile instead of creating new one, as that could trigger a max_bars_back error when drawing lines for old profiles that are first drawn when newer blocks break
                        bear_ob_confirmed.align_to_profile(align_edge_to_value_area, align_break_price_to_poc)

                    if not align_break_price_to_poc
                        bear_ob_confirmed.break_price := math.avg(bear_ob.left_top.price, bear_ob.right_bottom.price)
                    bear_ob.profile := na        
                    
                    bear_ob_confirmed.plot := D.create_box(bear_ob_confirmed.left_top, bear_ob_confirmed.right_bottom, config_bear.txt, config_bear.args, config_bear.txt_args, init_plot, force_overlay )       
                    tracking_blocks_bear.push(bear_ob_confirmed)

                    // START NEXT BEAR BLOCK
                    if barstate.isconfirmed// and bear_ob.early_confirmation_price > close
                        bear_ob.reset_tracking()

                    next_id += 1
                    bear_ob.id := next_id
                    is_unlocked_equilibrium_confirmation_bear := false

                else // INVALID SIZE, START NEXT BEAR BLOCK
                    bear_ob.reset_tracking()

    [tracking_blocks_bull, tracking_blocks_bear, bull_ob_confirmed, bear_ob_confirmed, broken_blocks_bull, broken_blocks_bear]


export method draw(OrderBlock this, OrderBlockConfig config, bool extend_only = true) =>

    if not na(this) and (barstate.islastconfirmedhistory or barstate.islast and barstate.isconfirmed) and config.show
        args = this.broken ? config.broken_args : config.args
        targs = this.broken ? config.broken_txt_args : config.txt_args
        txt_fvg = this.has_fvg_out ? '+FVG' : ''
        txt_probability = config.show_probability and this.probability > 0 ? str.format(' ({0,number,percent})', this.probability) : ''
        txt_id = config.show_id ? ' #' + str.tostring(this.id) : ''        
        txt = str.format('{0}{1}{2}{3}', config.txt, txt_fvg, txt_probability, txt_id)

        if  na(this.plot)
            this.plot := D.create_box(this.left_top, this.right_bottom, txt, args, targs, init_plot = true, force_overlay = false).draw()
        else
            this.plot.update(this.left_top, chart.point.now(this.right_bottom.price))
            this.plot.apply_style(args, targs)
            this.plot.txt := txt
            this.plot.draw(extend_only)

        if not na(config.broken_txt)
            this.plot.plot.set_text(str.format('{0}{1}{2}{3}', config.broken_txt, txt_fvg, txt_probability, txt_id))
        else
            this.plot.plot.set_text(this.plot.txt)

        if na(this.profile) ? false : config.show_profile
            profile_args = this.broken ? config.broken_profile_args : config.profile_args
            this.profile.draw(this.left_top.time, this.left_top.index, forced_width = this.right_bottom.index - this.left_top.index, extend_only = extend_only)
            this.profile.apply_style(profile_args)
        this.hidden := false
    this

// Hide order blocks
// @function hide the plot of an object, without deleting it from the chart, so it can re-appear later without triggering a max_bars_back error when redrawing an object that has a x coordinate > 244 bars in the past (the limit for the default buffer)
export method hide(OrderBlock this) =>
    if not na(this) and not this.hidden
        this.plot.hide()
        this.profile.hide()
        this.hidden := true
        

//Plot order blocks
// @function INTERNAL: plot order blocks
// @param show_ob switch to enable/disable plotting
// @param ob_top ob coordinates top
// @param ob_btm ob coordinates btm
// @param ob_left ob coordinates left
// @param ob_type ob coordinates type
// @param ob_showlast limit plotting to last x boxes (sets the buffer size for stored boxes)
// @param bull_ob_css color for bullish order blocks
// @param bear_ob_css color for bearish order blocks
export method draw(OrderBlock[] blocks, OrderBlockConfig config) =>
    if config.show
        total = blocks.size()
        i = 0    
        for block in blocks
            if i < total - config.show_last
                if not na(block.plot) and not block.hidden
                    block.hide()
                i += 1
            else
                block.draw(config)

    blocks

//Plot order blocks
// @function INTERNAL: plot order blocks
// @param show_ob switch to enable/disable plotting
// @param ob_top ob coordinates top
// @param ob_btm ob coordinates btm
// @param ob_left ob coordinates left
// @param ob_type ob coordinates type
// @param ob_showlast limit plotting to last x boxes (sets the buffer size for stored boxes)
// @param bull_ob_css color for bullish order blocks
// @param bear_ob_css color for bearish order blocks
export method draw(map<int,OrderBlock> blocks, OrderBlockConfig config) =>
    blocks.values().draw(config)
    blocks

//@function removes all Profiles that are older than the latest OrderBlock from this profile buffer
export method cleanup(PF.Profile[] this, OrderBlock ob_bull, OrderBlock ob_bear) =>
    // remove all Profiles with start_i < min
    // ignore internal structure, since there may be multiple before the next swing structure point is confirmed incl. lookback)
    if this.size() > 0
        min_idx = math.max(na(ob_bull) ? 0 : ob_bull.left_top.index, na(ob_bear) ? 0 : ob_bear.left_top.index)
        if min_idx > 0
            for i = this.size() - 1 to 0
                p = this.get(i)
                if p.start_i < min_idx
                    this.remove(i)
    this

    
//-----------------------------------------------------------------------------}
//Pivot Points
//-----------------------------------------------------------------------------{

// @function INTERNAL: plot swing points
// @param mode 1: bullish, -1 bearish block
// @param x x-coordingate of swing point to plot (bar_index)
// @param y y-coordingate of swing point to plot (price)
// @param show_swing_points switch to enable/disable plotting of swing point labels
// @param linecolor_swings color for swing point labels and lates level lines
// @param keep_history weater to remove older swing point labels and only keep the most recent
// @param show_latest_swing_levels whether to plot lines from the latest swing points/levels
// @param trail_x x-coordinate for latest swing point (bar_index)
// @param trail_y y-coordinate for latest swing point (price)
// @param trend the current trend 1: bullish, -1: bearish, to determine Strong/Weak Low/Highs
export _plot_swing_points(int mode, int x, float y, bool show_swing_points, color linecolor_swings, bool keep_history, bool show_latest_swings_levels, int trail_x, float trail_y, int trend) =>
    var string lbl_style = mode == 1 ? label.style_label_down : label.style_label_up
    var line line_latest_swing = line.new(na, na, na, na, color = linecolor_swings)
    var label label_latest_swing = label.new(na, na, color = #00000000, textcolor = linecolor_swings, style = lbl_style, size = size.tiny)

    if show_swing_points
        txt_swing_point = 
         mode ==  1 ? (y > y[1] ? 'HH' : 'LH') : 
         mode == -1 ? (y < y[1] ? 'LL' : 'HL') : 
         na
        label_swing_point = label.new(x, y, txt_swing_point, color = #00000000, textcolor = linecolor_swings, style = lbl_style, size = size.small)

        if not keep_history
            label.delete(label_swing_point[1])


    //Set lvl extension label/line
    if (barstate.islastconfirmedhistory or barstate.islast) and show_latest_swings_levels
        //Extend recent lvl to last bar
        hl_swing_txt = 
         mode ==  1 ? (trend < 0 ? 'Strong High' : 'Weak High') : 
         mode == -1 ? (trend > 0 ? 'Strong Low' : 'Weak Low') : 
         na

        if trail_x != line_latest_swing.get_x1() or na(line_latest_swing.get_x1())
            line_latest_swing.set_xy1(trail_x, trail_y)
        else
            line_latest_swing.set_y1(trail_y)

        line_latest_swing.set_xy2(bar_index + 20, trail_y)
        label_latest_swing.set_xy(bar_index + 20, trail_y)
        label_latest_swing.set_text(hl_swing_txt)


// @function INTERNAL: detect whether a structural level has been broken and if it was in trend direction (BoS) or against trend direction (ChoCh), also track the latest high and low swing points
// @param mode detect 1: bullish, -1 bearish pivot points
// @param trend current trend direction
// @param hhll_x x-coordinate of newly detected hh/ll (bar_index)
// @param hhll y-coordinate of newly detected hh/ll (price)
// @param super_hhll level/y-coordinate of superior hhll (if this is an internal structure pivot level)
// @param filter_insignificant_internal_breaks if true pivot points / internal structure will be ignored where the wick in trend direction is longer than the opposite (likely to push further in direction of main trend)
// @returns [x, y, trail_x, trail_y, bos_alert, choch_alert] coordinates of internal structure that has been broken (x,y): start of structure, (trail_x, trail_y): tracking hh/ll after structure break, (bos_alert,  choch_alert): signal whether a structural level has been broken
export _pivot_lvl(simple int mode, int trend, int hhll_x, float hhll, float super_hhll = na, bool filter_insignificant_internal_breaks = false) =>
    mode_high = mode == 1
    mode_low = mode == -1
    var sy = 0.
    var x = 0, var y = 0.
    var trail_x = 0, var trail_y = mode_high ? high : mode_low ? low : na
    var lvl_cross = true
    bool choch_alert = false
    bool bos_alert = false

    //-----------------------------------------------------------------------------}
    // Track Pivot level high/low
    //-----------------------------------------------------------------------------{
    if not na(super_hhll)
        sy := super_hhll

    if not na(hhll)
        lvl_cross := true
        y := hhll
        x := hhll_x
        trail_y := hhll
        trail_x := hhll_x

    //Trailing maximum
    trail_y := mode_high ? math.max(high, trail_y) : math.min(low, trail_y)
    trail_x := (mode_high and trail_y == high) or (mode_low and trail_y == low) ? bar_index : trail_x

    //-----------------------------------------------------------------------------}
    // Calculate BOS/CHoCH
    //-----------------------------------------------------------------------------{

    //Filtering
    var trend_concordant = true // in direction of trend
    atr = ta.atr(3)

    //Detect Structure
    structure_detected = switch mode
        1 => ta.crossover(close, y)
        -1 => ta.crossunder(close, y)
        => false
        
    if structure_detected and lvl_cross and y != sy // and trend_concordant
        lvl_cross := false

        if filter_insignificant_internal_breaks
            body = math.abs(open - close)
            distance_to_level = math.abs(open - y)
            big_candle = body > 2 * distance_to_level or body > atr
            
            top_wick = high - math.max(close, open)
            btm_wick = math.min(close, open) - low
            impulse_wick = switch mode 
                1 => top_wick > btm_wick
                -1 => top_wick < btm_wick
                => false

            trend_concordant := big_candle or impulse_wick

        if trend_concordant
            _trend = (trend != 1 and trend != -1 ? 1 : trend)
            choch_alert := mode == _trend * -1
            bos_alert := mode == _trend

    [x, y, trail_x, trail_y, bos_alert, choch_alert]

// @function INTERNAL: plot structural breaks (BoS/ChoCh)
// @param x x-coordinate of newly broken structure (bar_index)
// @param y y-coordinate of newly broken structure (price)
// @param is_bos whether this structural break was in trend direction 
// @param is_choch whether this structural break was against trend direction
// @param line_color color for the line connecting the structural level and the breaking candle
// @param line_style style (line.style_dashed/solid) for the line connecting the structural level and the breaking candle
// @param label_style style (label.style_label_down/up) for the label above/below the line connecting the structural level and the breaking candle
// @param label_size size (size.small/tiny) for the label above/below the line connecting the structural level and the breaking candle
// @param keep_history weater to remove older swing point labels and only keep the most recent
export _plot_structure(int x, float y, bool is_bos = false, bool is_choch = false, color line_color, string line_style, string label_style, string label_size, bool keep_history) =>
    //Detect Structure
    if is_bos or is_choch
        txt = is_choch ? 'CHoCH' : 'BOS'

        structure_line = line.new(x, y, bar_index, y, color = line_color, style = line_style)
        structure_lbl = label.new(int(math.avg(x, bar_index)), y, txt, color = #00000000, textcolor = line_color, style = label_style, size = label_size)

        if not keep_history
            line.delete(structure_line[1])
            label.delete(structure_lbl[1])


// @function detect (and plot) structural breaks and the resulting new trend
// @param length lookback period for swing point detection
// @param super_hh level/y-coordinate of superior hh (for internal structure detection)
// @param super_ll level/y-coordinate of superior ll (for internal structure detection)
// @param filter_insignificant_internal_breaks if true pivot points / internal structure will be ignored where the wick in trend direction is longer than the opposite (likely to push further in direction of main trend)
// @param keep_history weater to remove older swing point labels and only keep the most recent
// @returns [trend, bull_bos_alert, bull_choch_alert, top_x, top_y, trail_up_x, trail_up, hh, bear_bos_alert, bear_choch_alert, btm_x, btm_y, trail_dn_x, trail_dn, ll, hhll_x] trend: direction 1:bullish -1:bearish, (bull_bos_alert, bull_choch_alert, top_x, top_y, trail_up_x, trail_up): whether and which level broke in a bullish direction, trailing high, (bbear_bos_alert, bear_choch_alert, tm_x, btm_y, trail_dn_x, trail_dn): same in bearish direction
export structure_values(int length, float super_hh = na, float super_ll = na, bool filter_insignificant_internal_breaks) =>
    // swing structure
    var trend = 1

    [hhll_x, hh, ll] = swings(length)
    [top_x, top_y, trail_up_x, trail_up, bull_bos_alert, bull_choch_alert] = _pivot_lvl(1, trend, hhll_x, hh, super_hh, filter_insignificant_internal_breaks)
    [btm_x, btm_y, trail_dn_x, trail_dn, bear_bos_alert, bear_choch_alert] = _pivot_lvl(-1, trend, hhll_x, ll, super_ll, filter_insignificant_internal_breaks)
    
    trend := bull_choch_alert ? 1 : bear_choch_alert ? -1 : trend

    [trend, bull_bos_alert, bull_choch_alert, top_x, top_y, trail_up_x, trail_up, hh, bear_bos_alert, bear_choch_alert, btm_x, btm_y, trail_dn_x, trail_dn, ll, hhll_x]

// @function detect (and plot) structural breaks and the resulting new trend
// @param trend crrent trend 1: bullish, -1: bearish
// @param bull_bos_alert if there was a bullish bos alert -> plot it
// @param bull_choch_alert if there was a bullish choch alert -> plot it
// @param top_x latest shwing high x
// @param top_y latest swing high y
// @param trail_up_x trailing high x
// @param trail_up trailing high y
// @param hh if there was a higher high
// @param bear_bos_alert if there was a bearish bos alert -> plot it
// @param bear_choch_alert if there was a bearish chock alert -> plot it
// @param btm_x latest swing low x
// @param btm_y latest swing low y
// @param trail_dn_x trailing low x
// @param trail_dn trailing low y
// @param ll if there was a lower low
// @param color_bull color for bullish BoS/ChoCh levels
// @param color_bear color for bearish BoS/ChoCh levels
// @param super_hh level/y-coordinate of superior hh (for internal structure detection)
// @param super_ll level/y-coordinate of superior ll (for internal structure detection)
// @param filter_insignificant_internal_breaks if true pivot points / internal structure will be ignored where the wick in trend direction is longer than the opposite (likely to push further in direction of main trend)
// @param show_swing_points whether to plot swing point labels
// @param show_latest_swings_levels whether to track and plot latest swing point levels with lines
// @param show_bos whether to plot BoS levels
// @param show_choch whether to plot ChoCh levels
// @param line_style whether to plot BoS levels
// @param label_size label size of plotted BoS/ChoCh levels
// @param keep_history weater to remove older swing point labels and only keep the most recent
export structure_plot(int trend, bool bull_bos_alert, bool bull_choch_alert, int top_x, float top_y, int trail_up_x, float trail_up, float hh, bool bear_bos_alert, bool bear_choch_alert, int btm_x, float btm_y, int trail_dn_x, float trail_dn, float ll, color color_bull, color color_bear, bool show_swing_points = true, bool show_latest_swings_levels = true, bool show_bos = true, bool show_choch = true, string line_style = line.style_solid, string label_size = size.tiny, bool keep_history = true) =>
    _plot_swing_points(1, top_x, top_y, show_swing_points and not na(hh), color_bear, keep_history, show_latest_swings_levels, trail_up_x, trail_up, trend)
    _plot_swing_points(-1, btm_x, btm_y, show_swing_points and not na(ll), color_bull, keep_history, show_latest_swings_levels, trail_dn_x, trail_dn, trend)
    
    _plot_structure(top_x, top_y, show_bos and bull_bos_alert, show_choch and bull_choch_alert, color_bull, line_style, label.style_label_down, label_size, keep_history)
    _plot_structure(btm_x, btm_y, show_bos and bear_bos_alert, show_choch and bear_choch_alert, color_bear, line_style, label.style_label_up, label_size, keep_history)


// @function detect (and plot) structural breaks and the resulting new trend
// @param length lookback period for swing point detection
// @param color_bull color for bullish BoS/ChoCh levels
// @param color_bear color for bearish BoS/ChoCh levels
// @param super_hh level/y-coordinate of superior hh (for internal structure detection)
// @param super_ll level/y-coordinate of superior ll (for internal structure detection)
// @param filter_insignificant_internal_breaks if true pivot points / internal structure will be ignored where the wick in trend direction is longer than the opposite (likely to push further in direction of main trend)
// @param show_swing_points whether to plot swing point labels
// @param show_latest_swings_levels whether to track and plot latest swing point levels with lines
// @param show_bos whether to plot BoS levels
// @param show_choch whether to plot ChoCh levels
// @param line_style whether to plot BoS levels
// @param label_size label size of plotted BoS/ChoCh levels
// @param keep_history weater to remove older swing point labels and only keep the most recent
export structure(int length, color color_bull, color color_bear, float super_hh = na, float super_ll = na, bool filter_insignificant_internal_breaks, bool show_swing_points = true, bool show_latest_swings_levels = true, bool show_bos = true, bool show_choch = true, string line_style = line.style_solid, string label_size = size.tiny, bool keep_history = true, bool enabled = true) =>
    // swing structure
    var trend = 1

    [hhll_x, hh, ll] = swings(length)
    [top_x, top_y, trail_up_x, trail_up, bull_bos_alert, bull_choch_alert] = _pivot_lvl(1, trend, hhll_x, hh, super_hh, filter_insignificant_internal_breaks)
    [btm_x, btm_y, trail_dn_x, trail_dn, bear_bos_alert, bear_choch_alert] = _pivot_lvl(-1, trend, hhll_x, ll, super_ll, filter_insignificant_internal_breaks)
    
    trend := bull_choch_alert ? 1 : bear_choch_alert ? -1 : trend

    _plot_swing_points(1, top_x, top_y, enabled and show_swing_points and not na(hh), color_bear, keep_history, show_latest_swings_levels, trail_up_x, trail_up, trend)
    _plot_swing_points(-1, btm_x, btm_y, enabled and show_swing_points and not na(ll), color_bull, keep_history, show_latest_swings_levels, trail_dn_x, trail_dn, trend)
    
    _plot_structure(top_x, top_y, show_bos and bull_bos_alert, show_choch and bull_choch_alert, color_bull, line_style, label.style_label_down, label_size, keep_history)
    _plot_structure(btm_x, btm_y, show_bos and bear_bos_alert, show_choch and bear_choch_alert, color_bear, line_style, label.style_label_up, label_size, keep_history)

    [trend, bull_bos_alert, bull_choch_alert, top_x, top_y, trail_up_x, trail_up, hh, bear_bos_alert, bear_choch_alert, btm_x, btm_y, trail_dn_x, trail_dn, ll, hhll_x]


//-----------------------------------------------------------------------------}
// Check equal highs/lows
//-----------------------------------------------------------------------------{
// @function INTERNAL: detect equal levels (double top/bottom)
// @param mode detect 1: bullish/high, -1 bearish/low pivot points
// @param len lookback period for equal level (swing point) detection
// @param eq_threshold maximum price offset for a level to be considered equal
// @returns [eq_alert, x1, y1, x2, y2] eq_alert whether an equal level was detected and coordinates of the first and the second level/swing point
export _check_equal_level(int mode, int len, float eq_threshold, bool enabled = true) =>
    mode_high = mode == 1
    mode_low = mode == -1
    var int x1 = 0, var float y1 = 0.
    var int x2 = 0, var float y2 = 0.
    
    eq_alert = false
    ph = ta.pivothigh(len, len)
    pl = ta.pivotlow(len, len)

    if enabled
        eq_lvl = mode_high ? ph : pl
        
        if not na(eq_lvl)
            x1 := x2, y1 := y2 // move last known pivot point #2 to #1
            x2 := bar_index-len, y2 := eq_lvl // store new pivot point in #2

            max = math.max(eq_lvl, y1)
            min = math.min(eq_lvl, y1)

            // check if new pivot point is withing "equal" zone/threshold
            if mode_high and (max < min + eq_threshold)
             or mode_low and (min > max - eq_threshold)
                eq_alert := true

    [eq_alert, 
     eq_alert ? x1 : na, 
     eq_alert ? y1 : na, 
     eq_alert ? x2 : na, 
     eq_alert ? y2 : na]

// @function INTERNAL: plot equal levels (double top/bottom)
// @param show_eq whether to plot the level or not
// @param x1 x-coordinate of the first level / swing point
// @param y1 y-coordinate of the first level / swing point
// @param x2 x-coordinate of the second level / swing point
// @param y2 y-coordinate of the second level / swing point
// @param label_txt text for the label above/below the line connecting the equal levels
// @param label_style style (label.style_label_down/up) for the label above/below the line connecting the equal levels
// @param label_size size (size.tiny) for the label above/below the line connecting the equal levels
// @param line_color color for the line connecting the equal levels (and it's label)
// @param line_style style (line.style_dotted) for the line connecting the equal levels
// @param keep_history weater to remove older swing point labels and only keep the most recent
export _plot_equal_level(bool show_eq, int x1, float y1, int x2, float y2, string label_txt, string label_style = label.style_label_down, string label_size = size.tiny, color line_color, string line_style = line.style_dotted, bool keep_history = true ) =>
    if show_eq and not na(x1) and not na(x2) and not na(y1) and not na(y2)
        eq_line = line.new(x1, y1, x2, y2, color = line_color, style = line_style)
        eq_lbl = label.new(int(math.avg(x1, x2)), math.avg(y1, y2), label_txt, color = #00000000, textcolor = line_color, style = label_style, size = label_size)

        if not keep_history
            line.delete(eq_line[1])
            label.delete(eq_lbl[1])

// @function detect (and plot) equal levels (double top/bottom), returns coordinates
// @param len lookback period for equal level (swing point) detection
// @param threshold maximum price offset for a level to be considered equal
// @param color_eqh color for the line connecting the equal highs (and it's label)
// @param color_eql color for the line connecting the equal lows (and it's label)
// @param enabled whether detection is enabled
// @param show whether plotting is enabled
// @param keep_history weater to remove older swing point labels and only keep the most recent
// @returns [eqh_alert, eqh_x1, eqh_y1, eqh_x2, eqh_y2, eql_alert, eql_x1, eql_y1, eql_x2, eql_y2] (eqh_alert, eqh_x1, eqh_y1, eqh_x2, eqh_y2) whether an equal high was detected and coordinates of the first and the second level/swing point, (eql_alert, eql_x1, eql_y1, eql_x2, eql_y2) same for equal lows
export equal_levels_values(int len, float threshold, bool enabled = true) => 
    [eqh_alert, eqh_x1, eqh_y1, eqh_x2, eqh_y2] = _check_equal_level(1, len, threshold, enabled)
    [eql_alert, eql_x1, eql_y1, eql_x2, eql_y2] = _check_equal_level(-1, len, threshold, enabled)

    [eqh_alert, eqh_x1, eqh_y1, eqh_x2, eqh_y2, eql_alert, eql_x1, eql_y1, eql_x2, eql_y2]

// @function detect (and plot) equal levels (double top/bottom), returns coordinates
// @param eqh_x1 coordinates of first point of equal high
// @param eqh_y1 coordinates of first point of equal high
// @param eqh_x2 coordinates of second point of equal high
// @param eqh_y2 coordinates of second point of equal high
// @param eql_x1 coordinates of first point of equal low
// @param eql_y1 coordinates of first point of equal low
// @param eql_x2 coordinates of second point of equal low
// @param eql_y2 coordinates of second point of equal low
// @param color_eqh color for the line connecting the equal highs (and it's label)
// @param color_eql color for the line connecting the equal lows (and it's label)
// @param enabled whether detection is enabled
// @param show whether plotting is enabled
// @param keep_history weater to remove older swing point labels and only keep the most recent
// @returns [eqh_alert, eqh_x1, eqh_y1, eqh_x2, eqh_y2, eql_alert, eql_x1, eql_y1, eql_x2, eql_y2] (eqh_alert, eqh_x1, eqh_y1, eqh_x2, eqh_y2) whether an equal high was detected and coordinates of the first and the second level/swing point, (eql_alert, eql_x1, eql_y1, eql_x2, eql_y2) same for equal lows
export equal_levels_plot(int eqh_x1, float eqh_y1, int eqh_x2, float eqh_y2, int eql_x1, float eql_y1, int eql_x2, float eql_y2, color color_eqh, color color_eql, bool show = true, bool keep_history = true) => 
    _plot_equal_level(show, eqh_x1, eqh_y1, eqh_x2, eqh_y2, 'EQH', label.style_label_down, line_color = color_eqh, keep_history = keep_history)
    _plot_equal_level(show, eql_x1, eql_y1, eql_x2, eql_y2, 'EQL', label.style_label_up, line_color = color_eql, keep_history = keep_history)

// @function detect (and plot) equal levels (double top/bottom)
// @param len lookback period for equal level (swing point) detection
// @param threshold maximum price offset for a level to be considered equal
// @param color_eqh color for the line connecting the equal highs (and it's label)
// @param color_eql color for the line connecting the equal lows (and it's label)
// @param enabled whether detection is enabled
// @param show whether plotting is enabled
// @param keep_history weater to remove older swing point labels and only keep the most recent
// @returns [eqh_alert, eql_alert] (eqh_alert) whether an equal high was detected, (eql_alert) same for equal lows
export equal_levels(int len, float threshold, color color_eqh, color color_eql, bool enabled = true, bool show = true, bool keep_history = true) => 
    [eqh_alert, eqh_x1, eqh_y1, eqh_x2, eqh_y2, eql_alert, eql_x1, eql_y1, eql_x2, eql_y2] = equal_levels_values(len, threshold, enabled)
    equal_levels_plot(eqh_x1, eqh_y1, eqh_x2, eqh_y2, eql_x1, eql_y1, eql_x2, eql_y2, color_eqh, color_eql, show, keep_history)
    [eqh_alert, eqh_x1, eqh_y1, eqh_x2, eqh_y2, eql_alert, eql_x1, eql_y1, eql_x2, eql_y2]


//-----------------------------------------------------------------------------}
// Check FVG (fair value gaps)
//-----------------------------------------------------------------------------{

// @function INTERNAL: detect FVG (fair value gap)
// @param mode detect 1: bullish, -1 bearish gaps
// @param enabled whether detection is enabled
// @param o reference source open
// @param h reference source high
// @param l reference source low
// @param c reference source close
// @param filter_insignificant_fvgs whether to calculate and filter small/insignificant gaps
// @param change_tf signal when the previous reference timeframe closed, triggers new calculation
// @returns [cnd, top, mid, btm] whether a new FVG was detected and its top/mid/bottom levels
export _detect_fvg(int mode, bool enabled, float o, float h, float l, float c, bool filter_insignificant_fvgs, bool change_tf) =>
    // float top = na
    // float mid = na
    // float btm = na
    int _mode = mode

    delta_per = math.abs(c-o) / o * 100
    auto_threshold = ta.cum(math.abs(change_tf ? delta_per[1] : 0)) / bar_index * 2
    threshold = filter_insignificant_fvgs ? auto_threshold : 0
    
    //FVG conditions
    bool cnd_base = enabled and barstate.isconfirmed ? change_tf and delta_per[1] > threshold : false
    if not cnd_base
        _mode := 0
        
    bool fvg_found = switch _mode
        1  => l > h[2] and c[1] > h[2] and cnd_base
        -1 => h < l[2] and c[1] < l[2] and cnd_base
        => false

    if not fvg_found
        _mode := 0
        
    switch _mode
        1  => [true, l, math.avg(l, h[2]), h[2]]
        -1 => [true, h, math.avg(h, l[2]), l[2]]
        => [false, na, na, na]        


// @function INTERNAL: clear mitigated FVGs (fair value gaps)
// @param mode detect 1: bullish, -1 bearish gaps
// @param upper_boxes array<box> that stores the upper parts of the FVG boxes
// @param lower_boxes array<box> that stores the lower parts of the FVG boxes
export _clear_broken_fvg(int mode, array<box> upper_boxes, array<box> lower_boxes) =>
    fvg_count = array.size(upper_boxes)
    if barstate.isconfirmed and fvg_count > 0
        for int i = fvg_count-1 to 0
            box = switch mode 
                1  => array.get(lower_boxes, i)
                -1 => array.get(upper_boxes, i)

            do_delete = switch mode
                1  => low < box.get_bottom(box)
                -1 => high > box.get_top(box)
                => false

            if do_delete
                box.delete(array.remove(upper_boxes, i))
                box.delete(array.remove(lower_boxes, i))
            else
                break // assuming if this doesn't  need removal yet, all previous don't either, price moved away from them did not return all the way yet

// @function INTERNAL: plot (and clear broken) FVG (fair value gap)
// @param mode plot 1: bullish, -1 bearish gap
// @param show whether plotting is enabled
// @param top top level of fvg
// @param mid center level of fvg
// @param btm bottom level of fvg
// @param border_color color for the FVG box
// @param extend_box how many bars into the future the FVG box should be extended after detection
export _plot_fvg(int mode, bool show, float top, float mid, float btm, color border_color, int extend_box = 1) =>
    var upper_parts = array.new_box(0)
    var lower_parts = array.new_box(0)

    //FVG Areas
    if show
        array.unshift(upper_parts, box.new(bar_index-1, top, bar_index + extend_box, mid, border_color, bgcolor = border_color))
        array.unshift(lower_parts, box.new(bar_index-1, mid, bar_index + extend_box, btm, border_color, bgcolor = border_color))

    _clear_broken_fvg(mode, upper_parts, lower_parts)


// @function detect (and plot / clear broken) FVGs (fair value gaps), and return alerts and level values
// @param mode detect 1: bullish, -1 bearish gaps
// @param enabled whether detection is enabled
// @param o reference source open
// @param h reference source high
// @param l reference source low
// @param c reference source close
// @param filter_insignificant_fvgs whether to calculate and filter small/insignificant gaps
// @param change_tf signal when the previous reference timeframe closed, triggers new calculation
// @param color_bull color for bullish FVG boxes
// @param color_bear color for bearish FVG boxes
// @param extend_box how many bars into the future the FVG box should be extended after detection
// @param enabled whether detection is enabled
// @param show whether plotting is enabled
// @returns [bullish_fvg_alert, bull_top, bull_mid, bull_btm, bearish_fvg_alert, bear_top, bear_mid, bear_btm] (bullish_fvg_alert, bull_top, bull_mid, bull_btm): whether a new bullish FVG was detected and its top/mid/bottom levels, (bearish_fvg_alert, bear_top, bear_mid, bear_btm): same for bearish FVGs
export fvgs_values(float o, float h, float l, float c, bool filter_insignificant_fvgs, bool change_tf, bool enabled = true) =>
    [bullish_fvg_alert, bull_top, bull_mid, bull_btm] = _detect_fvg(1, enabled, o, h, l, c, filter_insignificant_fvgs, change_tf)
    [bearish_fvg_alert, bear_top, bear_mid, bear_btm] = _detect_fvg(-1, enabled, o, h, l, c, filter_insignificant_fvgs, change_tf)
    
    [bullish_fvg_alert, bull_top, bull_mid, bull_btm, bearish_fvg_alert, bear_top, bear_mid, bear_btm]

// @function detect (and plot / clear broken) FVGs (fair value gaps), and return alerts and level values

// @param filter_insignificant_fvgs whether to calculate and filter small/insignificant gaps
// @param change_tf signal when the previous reference timeframe closed, triggers new calculation
// @param color_bull color for bullish FVG boxes
// @param color_bear color for bearish FVG boxes
// @param extend_box how many bars into the future the FVG box should be extended after detection
// @param enabled whether detection is enabled
// @param show whether plotting is enabled
// @returns [bullish_fvg_alert, bull_top, bull_mid, bull_btm, bearish_fvg_alert, bear_top, bear_mid, bear_btm] (bullish_fvg_alert, bull_top, bull_mid, bull_btm): whether a new bullish FVG was detected and its top/mid/bottom levels, (bearish_fvg_alert, bear_top, bear_mid, bear_btm): same for bearish FVGs
export fvgs_plot(bool bullish_fvg_alert, float bull_top, float bull_mid, float bull_btm, bool bearish_fvg_alert, float bear_top, float bear_mid, float bear_btm, color color_bull, color color_bear, int extend_box = 1, bool show = true) =>
    _plot_fvg(1, show and bullish_fvg_alert, bull_top, bull_mid, bull_btm, color_bull, extend_box)
    _plot_fvg(-1, show and bearish_fvg_alert, bear_top, bear_mid, bear_btm, color_bear, extend_box)

// @function detect (and plot / clear broken) FVGs (fair value gaps)
// @param mode detect 1: bullish, -1 bearish gaps
// @param enabled whether detection is enabled
// @param o reference source open
// @param h reference source high
// @param l reference source low
// @param c reference source close
// @param filter_insignificant_fvgs whether to calculate and filter small/insignificant gaps
// @param change_tf signal when the previous reference timeframe closed, triggers new calculation
// @param color_bull color for bullish FVG boxes
// @param color_bear color for bearish FVG boxes
// @param extend_box how many bars into the future the FVG box should be extended after detection
// @param enabled whether detection is enabled
// @param show whether plotting is enabled
// @returns [bullish_fvg_alert, bearish_fvg_alert] (bullish_fvg_alert): whether a new bullish FVG was detected, (bearish_fvg_alert): same for bearish FVGs
export fvgs(float o, float h, float l, float c, bool filter_insignificant_fvgs, bool change_tf, color color_bull, color color_bear, int extend_box = 1, bool enabled = true, bool show = true) =>
    [bullish_fvg_alert, bull_top, bull_mid, bull_btm, bearish_fvg_alert, bear_top, bear_mid, bear_btm] = 
     fvgs_values(o, h, l, c, filter_insignificant_fvgs, change_tf, enabled)
    
    _plot_fvg(1, show and bullish_fvg_alert, bull_top, bull_mid, bull_btm, color_bull, extend_box)
    _plot_fvg(-1, show and bearish_fvg_alert, bear_top, bear_mid, bear_btm, color_bear, extend_box)

    [bullish_fvg_alert, bull_top, bull_mid, bull_btm, bearish_fvg_alert, bear_top, bear_mid, bear_btm]



// Functions Premium & Discount
// fill with return values of call to swings(len)
premium_discount_zones_values(int top_x, int btm_x, float trail_up, float trail_dn) =>
    x = math.max(top_x, btm_x)
    premium_top = trail_up
    premium_btm = .95 * trail_up + .05 * trail_dn
    eq_top = .525 * trail_up + .475 * trail_dn
    eq_btm = .525 * trail_dn + .475 * trail_up
    eq_center = math.avg(trail_up, trail_dn)
    discount_top = .95 * trail_dn + .05 * trail_up
    discount_btm = trail_dn
    [x, premium_top, premium_btm, eq_top, eq_center, eq_btm, discount_top, discount_btm]


premium_discount_zones_plot(bool show, int pd_start, float premium_top, float premium_btm, float eq_top, float eq_center, float eq_btm, float discount_top, float discount_btm, color color_premium, color color_equilibrium, color color_discount) =>
    var premium = box.new(na, na, na, na , bgcolor = color.new(color_premium, 80), border_color = na)
    var premium_lbl = label.new(na, na, text = 'Premium', color = #00000000, textcolor = color_premium, style = label.style_label_down, size = size.small)
    var eq = box.new(na, na, na, na, bgcolor = color.rgb(120, 123, 134, 80), border_color = na)
    var eq_lbl = label.new(na, na, text = 'Equilibrium', color = #00000000, textcolor = color_equilibrium, style = label.style_label_left, size = size.small)
    var discount = box.new(na, na, na, na, bgcolor = color.new(color_discount, 80), border_color = na)
    var discount_lbl = label.new(na, na, text = 'Discount', color = #00000000, textcolor = color_discount, style = label.style_label_up, size = size.small)
    
    if  show and barstate.isnew

        if bar_index - pd_start > 244
            label.new(bar_index, close, 'premium zone starts too far back')
        else
            box.set_lefttop(premium, pd_start, premium_top)
            box.set_rightbottom(premium, bar_index, premium_btm)
            label.set_xy(premium_lbl, int(math.avg(pd_start, bar_index)), premium_top)

            box.set_lefttop(eq, pd_start, eq_top)
            box.set_rightbottom(eq, bar_index, eq_btm)
            label.set_xy(eq_lbl, bar_index, eq_center)
            
            box.set_lefttop(discount, pd_start, discount_top)
            box.set_rightbottom(discount, bar_index, discount_btm)
            label.set_xy(discount_lbl, int(math.avg(pd_start, bar_index)), discount_btm)
        true
    false


//-----------------------------------------------------------------------------{
//Constants
//-----------------------------------------------------------------------------{

//Tooltips
string MODE_TOOLTIP          = 'Allows to display historical Structure or only the recent ones'
string STYLE_TOOLTIP         = 'Indicator color theme'
string COLOR_CANDLES_TOOLTIP = 'Display additional candles with a color reflecting the current trend detected by structure'
string SHOW_INTERNAL         = 'Display internal market structure'
string CONFLUENCE_FILTER     = 'Filter non significant internal structure breakouts'
string SHOW_SWING            = 'Display swing market Structure'
string SHOW_SWING_POINTS     = 'Display swing point as labels on the chart'
string SHOW_SWHL_POINTS      = 'Highlight most recent strong and weak high/low points on the chart'
string INTERNAL_OB           = 'Display internal order blocks on the chart\n\nNumber of internal order blocks to display on the chart'
string SWING_OB              = 'Display swing order blocks on the chart\n\nNumber of internal swing blocks to display on the chart'
string FILTER_OB             = "Order Block size filter, based on multiples of ATR. Each detected block must be in a specific range to be relevant. We don't want too small, but also not too big in case of spiking candles"
string SHOW_EQHL             = 'Display equal highs and equal lows on the chart'
string EQHL_BARS             = 'Number of bars used to confirm equal highs and equal lows'
string EQHL_THRESHOLD        = 'Sensitivity threshold in a range (0, 1) used for the detection of equal highs & lows\n\nLower values will return fewer but more pertinent results'
string SHOW_FVG              = 'Display fair values gaps on the chart'
string FILTER_FVG            = 'Filter out non significant fair value gaps'
string FVG_TF                = 'Fair value gaps timeframe'
string EXTEND_FVG            = 'Determine how many bars to extend the Fair Value Gap boxes on chart'
string PED_ZONES             = 'Display premium, discount, and equilibrium zones on chart'

//-----------------------------------------------------------------------------{
//Settings
//-----------------------------------------------------------------------------{
//General
//----------------------------------------{
mode = input.string('Historical', options = ['Historical', 'Present'], group = 'Smart Money Concepts', tooltip = MODE_TOOLTIP)
keep_history = mode == 'Historical'
show_trend = input(false, 'Color Candles', group = 'Smart Money Concepts', tooltip = COLOR_CANDLES_TOOLTIP)

//----------------------------------------}
//Internal Structure
//----------------------------------------{
var bool show_internals = input(false, 'Show Internal Structure', group = 'Real Time Internal Structure', tooltip = SHOW_INTERNAL)

// Bull Structure
var string show_ibull = input.string('All', 'Bullish Structure', options = ['All', 'BOS', 'CHoCH'], inline = 'ibull', group = 'Real Time Internal Structure')
var bool show_ibull_bos = show_internals and (show_ibull == 'All' or show_ibull == 'BOS')
var bool show_ibull_choch = show_internals and (show_ibull == 'All' or show_ibull == 'CHoCH')
var color ibull_css = input(#089981, '', inline = 'ibull', group = 'Real Time Internal Structure')

//Bear Structure
var string show_ibear = input.string('All', 'Bearish Structure', options = ['All', 'BOS', 'CHoCH'], inline = 'ibear', group = 'Real Time Internal Structure')
var bool show_ibear_bos = show_internals and (show_ibear == 'All' or show_ibear == 'BOS')
var bool show_ibear_choch = show_internals and (show_ibear == 'All' or show_ibear == 'CHoCH')
var color ibear_css = input(#f23645, '', inline = 'ibear', group = 'Real Time Internal Structure')

var bool ifilter_confluence = input(false, 'Confluence Filter', group = 'Real Time Internal Structure', tooltip = CONFLUENCE_FILTER)

//----------------------------------------}
//Swing Structure
//----------------------------------------{
var bool show_Structure = input(false, 'Show Swing Structure', group = 'Real Time Swing Structure', tooltip = SHOW_SWING)

//Bull Structure
var string show_bull = input.string('All', 'Bullish Structure', options = ['All', 'BOS', 'CHoCH'], inline = 'bull', group = 'Real Time Swing Structure')
var bool show_bull_bos = show_Structure and (show_bull == 'All' or show_bull == 'BOS')
var bool show_bull_choch = show_Structure and (show_bull == 'All' or show_bull == 'CHoCH')
var color bull_css = input(#089981, '', inline = 'bull', group = 'Real Time Swing Structure')

//Bear Structure
var string show_bear = input.string('All', 'Bearish Structure', options = ['All', 'BOS', 'CHoCH'], inline = 'bear', group = 'Real Time Swing Structure')
var bool show_bear_bos = show_Structure and (show_bear == 'All' or show_bear == 'BOS')
var bool show_bear_choch = show_Structure and (show_bear == 'All' or show_bear == 'CHoCH')
var color bear_css = input(#f23645, '', inline = 'bear', group = 'Real Time Swing Structure')



//Swings
show_swing_points = input(false, 'Show Swings Points', inline = 'swings', group = 'Real Time Swing Structure', tooltip = SHOW_SWING_POINTS)
length = input.int(50, '', minval = 10, inline = 'swings', group = 'Real Time Swing Structure')
ilength = input.int(5, 'Internal Swing Length', minval = 1, inline = 'internal swings', group = 'Real Time Swing Structure')
show_latest_swings_levels = input(true, 'Show Strong/Weak High/Low', group = 'Real Time Swing Structure', tooltip = SHOW_SWHL_POINTS)

//----------------------------------------}
//Order Blocks
//----------------------------------------{

show_ob = input(true, 'Order Blocks', inline = 'ob', group = 'Order Blocks', tooltip = SWING_OB)
ob_showlast = input.int(5, '', minval = 1, inline = 'ob', group = 'Order Blocks')
ob_filter_min_mult = input.float(0.2, 'Order Block Filter (ATR50 x) Min', minval = 0, step = 0.1 , inline =  'OB Filter', group = 'Order Blocks')
ob_filter_max_mult = input.float(2.5, 'Max', minval = 1, step = 0.1 , inline =  'OB Filter', group = 'Order Blocks', tooltip = FILTER_OB)

bull_ob_css = input.color(color.new(#1848cc, 80), 'Bullish OB', group = 'Order Blocks')
bear_ob_css = input.color(color.new(#b22833, 80), 'Bearish OB', group = 'Order Blocks')

show_ob_id = input.bool(false, 'show Order Block ID', group = 'Order Blocks')

//----------------------------------------}
//EQH/EQL
//----------------------------------------{
show_eq = input(false, 'Equal High/Low', group = 'EQH/EQL', tooltip = SHOW_EQHL)
eq_len = input.int(3, 'Bars Confirmation', minval = 1, group = 'EQH/EQL', tooltip = EQHL_BARS)
eq_threshold_in = input.float(0.1, 'Threshold', minval = 0, maxval = 0.5, step = 0.1, group = 'EQH/EQL', tooltip = EQHL_THRESHOLD)

//----------------------------------------}
//Fair Value Gaps
//----------------------------------------{
show_fvg = input(true, 'Fair Value Gaps', group = 'Fair Value Gaps', tooltip = SHOW_FVG)
filter_insignificant_fvgs = input(true, "Filter Insignificant FVGs", group = 'Fair Value Gaps', tooltip = FILTER_FVG)
fvg_tf = input.timeframe('', "Timeframe", group = 'Fair Value Gaps', tooltip = FVG_TF)
bull_fvg_css = input.color(color.new(#00ff68, 70), 'Bullish FVG', group = 'Fair Value Gaps')
bear_fvg_css = input.color(color.new(#ff0008, 70), 'Bearish FVG', group = 'Fair Value Gaps')
fvg_extend = input.int(1, "Extend FVG", minval = 0, group = 'Fair Value Gaps', tooltip = EXTEND_FVG)

//-----------------------------------------------------------------------------}
//Order Blocks Arrays
//-----------------------------------------------------------------------------


var PF.ProfileArgs profile_args_bull = PF.ProfileArgs.new(xloc = xloc.bar_time, extend = true, show_labels = true, args_poc_line = D.LineArgs.new(color.green, line.style_dashed, xloc = xloc.bar_time), args_poc_label = D.LabelArgs.new(color.green, xloc = xloc.bar_time, style = label.style_label_left, size = size.small))
var PF.ProfileArgs profile_args_bear = PF.ProfileArgs.new(xloc = xloc.bar_time , extend = true, show_labels = true, args_poc_line = D.LineArgs.new(color.red  , line.style_dashed, xloc = xloc.bar_time) , args_poc_label = D.LabelArgs.new(color.red, xloc = xloc.bar_time, style = label.style_label_left, size = size.small))

var OrderBlockConfig ob_config_bull = OrderBlockConfig.new(show_ob, ob_showlast, show_ob_id, show_profile = true,
 args = D.BoxArgs.new(bg_color = bull_ob_css, border_color = #00000000, xloc = xloc.bar_time),
 txt_args = D.BoxTextArgs.new(color.green, size.normal, text_halign = text.align_right),
 txt = 'OB â¬',
 profile_args = profile_args_bull
 )  
var OrderBlockConfig ob_config_bear = OrderBlockConfig.new(show_ob, ob_showlast, show_ob_id, show_profile = true,
 args = D.BoxArgs.new(bg_color = bear_ob_css, border_color = #00000000, xloc = xloc.bar_time),
 txt_args = D.BoxTextArgs.new(color.red, size.normal, text_halign = text.align_right),
 txt = 'OB â¬', 
 profile_args = profile_args_bear
 )  
 
var enable_structure = show_bull_bos or show_bear_bos or show_bull_choch or show_bear_choch or show_swing_points or show_latest_swings_levels
[trend, bull_bos_alert, bull_choch_alert, top_x, top, trail_up_x, trail_up, hh, bear_bos_alert, bear_choch_alert, btm_x, btm, trail_dn_x, trail_dn, ll, hhll_x] = 
 structure(length, bull_css, bear_css, na, na, false, show_swing_points, show_latest_swings_levels, show_bull_bos or show_bear_bos, show_bull_choch or show_bear_choch, line.style_solid, size.small, keep_history, enable_structure)

var extend_blocks = input.bool(true, 'extend blocks', group = 'Order Blocks')
var clear_broken_buffer = input.bool(true, 'clear broken blocks ', group = 'Order Blocks')
var use_ob_profile = input.bool(true, 'use OB profiles', display = display.none, group = 'Order Blocks')
var use_ob_soft_confirm = input.bool(true, 'use ob soft confirm', display = display.none, tooltip = 'After extension stop, price touched poc but then exited the block in trend direction. This would be a soft confirmation, often this allows to use the ob before the confirmation period of 50 bars or a structural break in trend direction', group = 'Order Blocks')
var soft_confirm_offset_atr_len = input.int(50, 'ATR len', inline = 'soft confirm', group = 'Order Blocks')
var soft_confirm_offset_atr_mult = input.float(1, 'x', inline = 'soft confirm', group = 'Order Blocks')
float soft_confirm_offset = ND.atr(soft_confirm_offset_atr_len) * soft_confirm_offset_atr_mult
var use_retracements_with_FVG_out = input.bool(true, 'use retracements with FVG out as trend supporting OB', display = display.none, tooltip = 'After extension stop, price continued in trend direction, rendering the extesion invalid. If this continuation happened with an FVG crossing the previous pivotal origin of the forming block, it can be seen as a retracement, which is a block of take profits followed by even more agressive entries supporting the trend. So instead of skipping the extension, we are using this information to create a flipped Order Block', group = 'Order Blocks')

ob_threshold_atr = ND.atr(50)
ob_threshold_min = ob_threshold_atr * ob_filter_min_mult
ob_threshold_max = ob_threshold_atr * ob_filter_max_mult

[ob_blocks_bull, ob_blocks_bear, new_ob_bull, new_ob_bear, ob_broken_bull, ob_broken_bear] = track_obs(length, hh, ll, trail_up, trail_dn, bull_bos_alert, bull_choch_alert, bear_bos_alert, bear_choch_alert, ob_threshold_min, ob_threshold_max, ob_config_bull, ob_config_bear, enabled = show_ob, extend_blocks = extend_blocks, clear_broken_buffer_before = clear_broken_buffer, align_edge_to_value_area = use_ob_profile, align_break_price_to_poc = use_ob_profile, profile_args_bull = profile_args_bull, profile_args_bear = profile_args_bear, use_soft_confirm = use_ob_soft_confirm, soft_confirm_offset = soft_confirm_offset, use_retracements_with_FVG_out = use_retracements_with_FVG_out)

ob_blocks_bull.draw(ob_config_bull)
ob_blocks_bear.draw(ob_config_bear)



//-----------------------------------------------------------------------------}
//EQH/EQL
//-----------------------------------------------------------------------------{

eq_atr = ND.atr(50)
eq_threshold = eq_threshold_in * eq_atr
[eqh_alert, eqh_x1, eqh_y1, eqh_x2, eqh_y2, eql_alert, eql_x1, eql_y1, eql_x2, eql_y2] = equal_levels(eq_len, eq_threshold, bear_css, bull_css, show_eq, show_eq, keep_history) 

//-----------------------------------------------------------------------------}
//Fair Value Gaps
//-----------------------------------------------------------------------------{

[fvg_o, fvg_h, fvg_l, fvg_c] = request.security(syminfo.tickerid, fvg_tf, [open, high, low, close])
change_fvg_tf = timeframe.change(fvg_tf)
[bullish_fvg_alert, bull_top, bull_mid, bull_btm, bearish_fvg_alert, bear_top, bear_mid, bear_btm] = fvgs(fvg_o, fvg_h, fvg_l, fvg_c, filter_insignificant_fvgs, change_fvg_tf, bull_fvg_css, bear_fvg_css, fvg_extend, show_fvg, show_fvg)

//-----------------------------------------------------------------------------}
//Trend
//-----------------------------------------------------------------------------{
// color trend_css = show_trend ? (itrend == 1 ? bull_css : bear_css) : na

// plotcandle(open, high, low, close
//   , color = trend_css
//   , wickcolor = trend_css
//   , bordercolor = trend_css
//   , editable = false
//   , display = display.pane)

//-----------------------------------------------------------------------------}
//Alerts
//-----------------------------------------------------------------------------{

//Swing Structure
alertcondition(bull_bos_alert, 'Bullish BOS', 'Internal Bullish BOS formed')
alertcondition(bull_choch_alert, 'Bullish CHoCH', 'Internal Bullish CHoCH formed')

alertcondition(ob_broken_bear.size() > 0, 'Bearish OB Breakout', 'Price broke bullish OB')
alertcondition(ob_broken_bull.size() > 0, 'Bullish OB Breakout', 'Price broke bearish OB')

//EQH/EQL
alertcondition(eqh_alert, 'Equal Highs', 'Equal highs detected')
alertcondition(eql_alert, 'Equal Lows', 'Equal lows detected')

//FVG
alertcondition(bullish_fvg_alert, 'Bullish FVG', 'Bullish FVG formed')
alertcondition(bearish_fvg_alert, 'Bearish FVG', 'Bearish FVG formed')

//-----------------------------------------------------------------------------}
